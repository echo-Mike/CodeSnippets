#pragma once
#ifndef PATTERNS_LIB_PIPELINE_HPP__
#define PATTERNS_LIB_PIPELINE_HPP__ "0.0.0@cPipeline.hpp"
/**
*   @file
*	DESCRIPTION:
*		Module contains implementation of pipeline pattern.
*	AUTHOR:
*		Mikhail Demchenko
*		mailto:dev.echo.mike@gmail.com
*		https://github.com/echo-Mike
**/
/** 
*   MIT License
*
*   Copyright (c) 2017 Mikhail Demchenko dev.echo.mike@gmail.com
*   
*   Permission is hereby granted, free of charge, to any person obtaining a copy
*   of this software and associated documentation files (the "Software"), to deal
*   in the Software without restriction, including without limitation the rights
*   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*   copies of the Software, and to permit persons to whom the Software is
*   furnished to do so, subject to the following conditions:
*   
*   The above copyright notice and this permission notice shall be included in all
*   copies or substantial portions of the Software.
*   
*   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
*   SOFTWARE.
**/
//STD
#include <exception>
#include <stdexcept>
#include <utility>
#include <iterator>
#include <type_traits>
#include <initializer_list>
//SNIPPETS
//#include <ClassUtilsLib/mClassUtils.hpp>
//#include <DebugLib/mDebugLib.hpp>

namespace Patterns {

    template < typename InterfaceT >
    class Pipeline
    {
    public:
        class PipelineEntry;
 
        /**
        *   Iterator type of container.
        **/
        class iterator
        {
        public:
            using Interface = InterfaceT;                               //!< Type of interface of pipeline element.
            using value_type = PipelineEntry;                           //!< Type of iterator value type. 
            using pointer = value_type*;                                //!< Type of pointer to value type. 
            using reference = value_type&;                              //!< Type of reference to value type. 
            using iterator_category = std::bidirectional_iterator_tag;  //!< Type of iterator tag for stl algorithms.
            using difference_type = std::ptrdiff_t;                     //!< Type of difference between iterators.
            
            /**
            *   @brief Default constructor.
            *   Default constructor.
            **/
            iterator() : current(nullptr), last(nullptr) {}

            /**
            *   @brief Default copy constructor.
            *   Default copy constructor is generated by compiler.
            **/
            iterator(const iterator&) = default;
            
            /**
            *   @brief Default copy assignment operator.
            *   Default copy assignment operator is generated by compiler.
            **/
            iterator& operator=(const iterator&) = default;
            
            /**
            *   @brief Constructor for explicit conversion from pointer type to iterator type.
            **/
            explicit iterator(const value_type* ptr) : 
                current(const_cast<pointer>(ptr)),
                last(nullptr) 
            {}

            /**
            *   @brief Default destructor.
            *   Default destructor is generated by compiler.
            **/
            ~iterator() = default;

            /**
            *   @brief Pre-increment operator.
            **/
            iterator& operator++() {
                if (current) last = current;
                current = (current && current->hasTail()) ? current->tail : nullptr;
                return *this;
            }

            /**
            *   @brief Post-increment operator.
            **/
            iterator operator++(int) {
                iterator old{ this };
                const_cast<iterator*>(this)->operator++();
                return old;
            }

            /**
            *   @brief Pre-decrement operator.
            **/
            iterator& operator--() {
                if (current) {
                    last = current;
                    current = current->hasHead() ? current->head : nullptr;
                } else if (last) {
                    current = last;
                    last = nullptr;
                }
                return *this;
            }

            /**
            *   @brief Post-decrement operator.
            **/
            iterator operator--(int) {
                iterator old{ this };
                const_cast<iterator*>(this)->operator--();
                return old;
            }

            /**
            *   @brief Member access operator.
            *   @return Pointer to handled object.
            **/
            pointer operator->() const { return current; }

            /**
            *   @brief Indirection (dereference) operator.
            *   @return Reference to handled object.
            **/
            reference operator*() const { return *current; }

            /**
            *   @brief Swap operation.
            *   @return Noreturn
            **/
            friend void swap(iterator& lhs, iterator& rhs) 
            { 
                std::swap(lhs.current, rhs.current);
                std::swap(lhs.last, rhs.last);
            }

            /**
            *   @brief Copmpare equal operator.
            **/
            friend inline bool operator==(const iterator& lhs, const iterator& rhs) 
            { return lhs.current == rhs.current; } //&& lhs.last == rhs.last; }

            /**
            *   @brief Copmpare not equal operator.
            **/
            friend bool operator!=(const iterator& lhs, const iterator& rhs) { return !(lhs == rhs); }
            
            /**
            *   @brief Check if iterator is pointing to something.
            **/
            operator bool() const { return static_cast<bool>(current); }

        protected:
            /**
            *   @brief Internal function to construct end() iterator from pointer to value.
            **/
            static iterator makeEnd(const value_type* ptr) 
            {
                iterator result;
                result.last = const_cast<pointer>(ptr);
                return result;
            }
        private:
			friend Pipeline;
            pointer current;    //!< Pointer to current element.
            pointer last;       //!< Pointer to last seen element.
        };

        /**
        *   Constant iterator type of container.
        **/
        class const_iterator
        {
        public:
            using Interface = InterfaceT;                               //!< Type of interface of pipeline element.
            using value_type = PipelineEntry;                           //!< Type of iterator value type. 
            using pointer = const value_type*;                          //!< Type of pointer to value type. 
            using reference = const value_type&;                        //!< Type of reference to value type. 
            using iterator_category = std::bidirectional_iterator_tag;  //!< Type of iterator tag for stl algorithms.
            using difference_type = std::ptrdiff_t;                     //!< Type of difference between iterators.

            /**
            *   @brief Default constructor.
            *   Default constructor.
            **/
            const_iterator() : current(nullptr), last(nullptr) {}
            
            /**
            *   @brief Default copy constructor.
            *   Default copy constructor is generated by compiler.
            **/
            const_iterator(const const_iterator&) = default;

            /**
            *   @brief Default copy assignment operator.
            *   Default copy assignment operator is generated by compiler.
            **/
            const_iterator& operator=(const const_iterator&) = default;

            /**
            *   @brief Constructor for implicit conversion from iterator type to const iterator type.
            **/
            const_iterator(const iterator& other) :
                current(other.current), last(other.last)
            {}
            
            /**
            *   @brief Assignment operator for implicit conversion from iterator type to const iterator type.
            **/
            const_iterator& operator=(const iterator& other) 
            {
                current = other.current;
                last = other.last;
            }
            
            /**
            *   @brief Constructor for explicit conversion from pointer type to const iterator type.
            **/
            explicit const_iterator(pointer ptr) : 
                current(ptr), last(nullptr) 
            {}

            /**
            *   @brief Default destructor.
            *   Default destructor is generated by compiler.
            **/
            ~const_iterator() = default;
            
            /**
            *   @brief Pre-increment operator.
            **/
            const_iterator& operator++() {
                if (current) last = current;
                current = (current && current->hasTail()) ? current->tail : nullptr;
                return *this;
            }

            /**
            *   @brief Pos-increment operator.
            **/
            const_iterator operator++(int) {
                const_iterator old{ this };
                const_cast<const_iterator*>(this)->operator++();
                return old;
            }

            /**
            *   @brief Pre-decrement operator.
            **/
            const_iterator& operator--() {
                if (current) {
                    last = current;
                    current = current->hasHead() ? current->head : nullptr;
                } else if (last) {
                    current = last;
                    last = nullptr;
                }
                return *this;
            }

            /**
            *   @brief Post-decrement operator.
            **/
            const_iterator operator--(int) {
                const_iterator old{ this };
                const_cast<const_iterator*>(this)->operator--();
                return old;
            }

            /**
            *   @brief Member access operator.
            *   @return Pointer to handled object.
            **/
            pointer operator->() const { return current; }

            /**
            *   @brief Indirection (dereference) operator.
            *   @return Reference to handled object.
            **/
            reference operator*() const { return *current; }
            
            /**
            *   @brief Swap operation.
            *   @return Noreturn
            **/
            friend void swap(const_iterator& lhs, const_iterator& rhs) 
            { 
                std::swap(lhs.current, rhs.current);
                std::swap(lhs.last, rhs.last);
            }

            /**
            *   @brief Copmpare equal operator.
            **/
            friend inline bool operator==(const const_iterator& lhs, const const_iterator& rhs)
            { return lhs.current == rhs.current; }// && lhs.last == rhs.last; }
            
            /**
            *   @brief Copmpare not equal operator.
            **/
            friend bool operator!=(const const_iterator& lhs, const const_iterator& rhs) { return !(lhs == rhs); }

            /**
            *   @brief Check if iterator is pointing to something.
            **/
            operator bool() const { return static_cast<bool>(current); }
        protected:
            /**
            *   @brief Internal function to construct end() iterator from pointer to value.
            **/
            static const_iterator makeEnd(const value_type* ptr) 
            {
                const_iterator result;
                result.last = ptr;
                return result;
            }

        private:
			friend Pipeline;
            pointer current;    //!< Pointer to current element.
            pointer last;       //!< Pointer to last seen element.
        };

        /**
        *   Proxy type for container elements.
        **/
        class PipelineEntry :
            public InterfaceT // Publicly derived from interface
        {
        public:
            using Interface = InterfaceT; // Type of interface.

            /**
            *   @brief Default constructor.
            *   Default constructor.
            **/
            PipelineEntry() : tail(nullptr), head(nullptr) {}
            
            /**
            *   @brief Virtual default destructor.
            *   Virtual default destructor.
            **/
            virtual ~PipelineEntry() = default;

            /**
            *   @brief Deleted copy constructor.
            *   PipelineEntry is not copyable by polymothic nature.
            **/
            PipelineEntry(const PipelineEntry&) = delete;

            /**
            *   @brief Deleted copy assignment operator.
            *   PipelineEntry is not copyable by polymothic nature.
            **/
            PipelineEntry& operator=(const PipelineEntry&) = delete;

            /**
            *   @brief Proper move constructor.
            *   Handles the tail and head chains properly.
            **/
            PipelineEntry(PipelineEntry&& other) :
                head(other.head), tail(other.tail)
            {
                other.head = nullptr;
                other.tail = nullptr;
                if (head) head->tail = const_cast<PipelineEntry*>(this);
                if (tail) tail->head = const_cast<PipelineEntry*>(this);
            }

            /**
            *   @brief Proper move assignment operator.
            *   Handles the tail and head chains properly.
            **/
            PipelineEntry& operator=(PipelineEntry&& other)
            {
                if (this == &other) return *this;
                if (head) head->tail = tail;
                if (tail) tail->head = head;
                head = other.head;
                tail = other.tail;
                other.head = nullptr;
                other.tail = nullptr;
                if (head) head->tail = const_cast<PipelineEntry*>(this);
                if (tail) tail->head = const_cast<PipelineEntry*>(this);
                return *this;
            }

            /**
            *   @brief Access method for interface of tail element.
            *   Dynamicaly casts tail pointer to pointer to Interface.
            *   @return Pointer to tail element as Interface*.
            **/
            inline Interface* getTail() const { return dynamic_cast<Interface*>(tail); }
            
            /**
            *   @brief Performs a check that current element has tail element.
            *   @return true if tail element is presented, false otherwise.
            **/
            inline bool hasTail() const { return static_cast<bool>(tail); }
            
            /**
            *   @brief Access method for interface of head element.
            *   Dynamicaly casts head pointer to pointer to Interface.
            *   @return Pointer to head element as Interface*.
            **/
            inline Interface* getHead() const { return dynamic_cast<Interface*>(head); }
            
            /**
            *   @brief Performs a check that current element has head element.
            *   @return true if head element is presented, false otherwise.
            **/
            inline bool hasHead() const { return static_cast<bool>(head); }

            /**
            *   @brief Access method for interface of this element.
            *   Dynamicaly casts this pointer to pointer to Interface.
            *   @return Pointer to this element as Interface*.
            **/
            inline Interface* getThis() const { return dynamic_cast<Interface*>(const_cast<PipelineEntry*>(this)); }

        private:
			friend Pipeline;
            PipelineEntry* tail;    //!< Pointer to next element.
            PipelineEntry* head;    //!< Pointer to previous element.
        };

        using Interface = InterfaceT;       //!< Type of interface of pipeline element.
        using InterfacePtr = Interface*;    //!< Type of pointer to interface of pipeline element.
        using InterfaceRef = Interface&;    //!< Type of reference to interface of pipeline element.

        using value_type = PipelineEntry;   //!< Type of pipeline element.

        using size_type = std::size_t;      //!< Type of size of contaner.

        //using reverse_iterator = std::reverse_iterator<iterator>;
        //using const_reverse_iterator = std::reverse_iterator<const_iterator>;

        using difference_type = typename std::iterator_traits<iterator>::difference_type;   //!< Type of difference between iterators.

        using reference = value_type&;              //!< Type of reference to pipeline element.
        using const_reference = const value_type&;  //!< Type of const reference to pipeline element.
        using pointer = value_type*;                //!< Type of pointer to pipeline element.
        using const_pointer = const value_type*;    //!< Type of const pointer to pipeline element.

        /**
        *   @brief Default constructor.
        *   Default constructor.
        **/
        Pipeline() : head(nullptr), tail(nullptr) {}

        /**
        *   @brief Initializer list constructor.
        *   Used to construct const pipeline objects.\n
        *   If one or more pointers in l is nullptr construction does not occur.
        *   @param l Initializer list of pointers to pipeline entries.
        **/
        Pipeline(std::initializer_list<pointer> l) : 
            head(nullptr), tail(nullptr)
        {
            for (auto v : l) // Case when one of pointers are nullptr
                if (!(*v)) return;
            
            if ( l.size() > 0 ) {
                head = const_cast<pointer>(*l.begin());
                head->head = nullptr;
                head->tail = nullptr;
                if ( l.size() == 1 ) // Case when Pipeline{ptr_}
                    tail = head;
                else { // Case when Pipeline{ptr_1, ptr_2, ... , ptr_n}
                    auto startIter = ++l.begin(); // Next element past begin
                    auto endIter = --l.end(); // Last element in list
                    pointer last = head;
                    for (auto iter = startIter; iter != endIter; ++iter)
                    { // Building head and tail chains
                        last->tail = const_cast<pointer>(*iter); 
                        const_cast<pointer>(*iter)->head = last;
                        last = const_cast<pointer>(*iter);
                    }
                    tail = const_cast<pointer>(*endIter);
                    tail->head = last;
                    last->tail = tail;
                }
            }
        }

        /**
        *   @brief Deleted copy constructor.
        *   Pipeline is not copyable by polymothic nature of PipelineEntry.
        **/
        Pipeline(const Pipeline&) = delete;

        /**
        *   @brief Deleted copy assignment operator.
        *   Pipeline is not copyable by polymothic nature of PipelineEntry.
        **/
        Pipeline& operator=(const Pipeline&) = delete;

        /**
        *   @brief Proper move constructor.
        *   Handles the tail and head properly.
        **/
        Pipeline(Pipeline&& other) :
            head(other.head), tail(other.tail)
        {
            other.head = nullptr;
            other.tail = nullptr;
        }

        /**
        *   @brief Proper move assignment operator.
        *   Handles the tail and head properly.
        **/
        Pipeline& operator=(Pipeline&& other)
        {
            if (this == &other) return *this;
            head = other.head;
            tail = other.tail;
            other.head = nullptr;
            other.tail = nullptr;
            return *this;
        }

        /**
        *   @brief Default destructor.
        *   Deallocates memory used by elements of pipeline.
        **/
        ~Pipeline() noexcept { /*setHead();*/ clear(head); }

        /**
        *   @name Element access methods.
        **/
        //@{
        
        /**
        *   @brief Returns a reference to the first element in the container.
        *   Calling front on an empty container is undefined.\n
        *   Searches for the new head element on call.
        *   @return Reference to the first element.
        *   @complexity Linear in size of uncounted front elements or constant.
        **/
        reference front() { setHead(); return *head; }

        /**
        *   @brief Returns a reference to the first element in the container.
        *   Calling front on an empty container is undefined.\n
        *   Overload for constant containers.
        *   @return Reference to the first element.
        *   @complexity Constant.
        **/
        const_reference front() const { return *head; }

        /**
        *   @brief Returns reference to the last element in the container.
        *   Calling back on an empty container is undefined.\n
        *   Searches for the new tail element on call.
        *   @return Reference to the last element.
        *   @complexity Linear in size of uncounted back elements or constant.
        **/
        reference back() { setTail(); return *tail; }

        /**
        *   @brief Returns reference to the last element in the container.
        *   Calling back on an empty container is undefined.\n
        *   Overload for constant containers.        
        *   @return Reference to the last element.
        *   @complexity Constant.
        **/
        const_reference back() const { return *tail; }
        
        //@}

        /**
        *   @name Iterator access methods.
        **/
        //@{

        /**
        *   @brief Returns an iterator to the first element of the container.
        *   If the container is empty, the returned iterator will be equal to end().\n   
        *   Searches for the new head element on call.            
        *   @return Iterator to the first element.
        *   @complexity Linear in size of uncounted front elements or constant.
        **/
        iterator begin() noexcept { setHead(); return iterator{ head }; }
        
        /**
        *   @brief Returns a const iterator to the first element of the container.
        *   If the container is empty, the returned iterator will be equal to end().\n
        *   Overload for constant containers.  
        *   @return Const iterator to the first element.
        *   @complexity Constant.
        **/
        const_iterator begin() const noexcept { return const_iterator{ head }; }
        
        /**
        *   @brief Explicit function to obtain a const iterator to the first element of the container.
        *   If the container is empty, the returned iterator will be equal to end().
        *   @return Const iterator to the first element.
        *   @complexity Constant.
        **/
        const_iterator cbegin() const noexcept { return const_iterator{ head }; }

        /**
        *   @brief Returns an iterator to the element following the last element of the container.
        *   This element acts as a placeholder, attempting to access it results in undefined behavior.\n
        *   Searches for the new tail element on call.            
        *   @return Iterator to the element following the last element.
        *   @complexity Linear in size of uncounted back elements or constant.
        **/
        iterator end() noexcept { setTail(); return iterator::makeEnd(tail); }

        /**
        *   @brief Returns a const iterator to the element following the last element of the container.
        *   This element acts as a placeholder, attempting to access it results in undefined behavior.\n
        *   Overload for constant containers.
        *   @return Const iterator to the element following the last element.
        *   @complexity Constant.
        **/
        const_iterator end() const noexcept { return iterator::makeEnd(tail); }

        /**
        *   @brief Explicit function to obtain a const iterator to the element following the last element of the container.
        *   This element acts as a placeholder, attempting to access it results in undefined behavior. 
        *   @return Const iterator to the element following the last element.
        *   @complexity Constant.
        **/
        const_iterator cend() const noexcept { return iterator::makeEnd(tail); }

        //@}

        /**
        *   @name Capacity methods.
        **/
        //@{

        /**
        *   @brief Returns the number of elements in the container. 
        *   @return The number of elements in the container if container is good-linked, static_cast<size_type>(-1) otherwise.
        *   @complexity Linear.
        **/
        size_type size() const noexcept 
        {
            // setHead();
            // setTail();
            if (!head) return 0;
            auto first = head;
            auto last = tail;
            size_type result = 1;
            while ( first != last ) {
                if (first->tail) {
                    ++result;
                    first = first->tail;
                } else
                    return static_cast<size_type>(-1);
            }
            return result;
        }

        /**
        *   @brief Checks if the container has no elements. 
        *   @return true if the container is empty, false otherwise.
        *   @complexity Constant.
        **/
        bool empty() const noexcept { return !(static_cast<bool>(head) || static_cast<bool>(tail)); }
        
        //@}

        /**
        *   @name Container content modification methods.
        **/
        //@{

        /**
        *   @brief Removes all elements from the container.
        *   Invalidates any references, pointers, or iterators referring to contained elements.
        *   @return Noreturn.
        *   @complexity Linear in the size of the container, i.e., the number of elements.
        **/
        void clear() noexcept { setHead(); clear(head); head = nullptr; tail = nullptr; }

        /**
        *   @brief Appends the given element newBack to the end of the container.
        *   No iterators or references are invalidated except end() iterator.\n
        *   Searches for the new tail element on call.\n
        *   @param  newBack Pointer to new element.
        *   @return Noreturn.
        *   @complexity Linear in size of uncounted back elements or constant.
        **/
        void push_back(pointer newBack) noexcept
        {
            // Set real tail element
            setTail();
            if (tail) { // Case of non-empty container
                tail->tail = newBack;
                newBack->head = tail;
            } else // Case of empty container
                head = newBack;
            tail = newBack;
        }

        /**
        *   @brief Removes the last element of the container.
        *   References and iterators to the erased element are invalidated.\n
        *   end() iterators are invalidated.\n
        *   Searches for the new tail element on call.
        *   @return Pointer to poped element.
        *   @complexity Linear in size of uncounted back elements or constant.
        **/
        pointer pop_back() noexcept
        {
            // Set real tail element
            setTail();
            // Case of empty container
            if (!tail) return nullptr;
            // Setup new tail element
            pointer result = tail;
            tail = tail->head;
            // Clear links of returned element
            tail->tail = nullptr;
            result->head = nullptr;
            return result;
        }

        /**
        *   @brief Prepends the given element newFront to the end of the container.
        *   No iterators or references are invalidated\n
        *   Searches for the new head element on call before insertion.\n
        *   @param  newFront Pointer to new element.
        *   @return Noreturn.
        *   @complexity Linear in size of uncounted front elements or constant.
        **/
        void push_front(pointer newFront) noexcept
        {
            // Set real head element
            setHead();
            if (head) { // Case of non-empty container
                head->head = newFront;
                newFront->tail = head;
            } else // Case of empty container
                tail = newFront;
            head = newFront;
        }

        /**
        *   @brief Removes the first element of the container.
        *   References and iterators to the erased element are invalidated.\n
        *   Searches for the new head element on call before pop operation.
        *   @return Pointer to poped element.
        *   @complexity Linear in size of uncounted front elements or constant.
        **/
        pointer pop_front() noexcept
        {
            // Set real head element
            setHead();
            // Case of empty container
            if (!head) return nullptr;
            // Setup new head element
            pointer result = head;
            head = head->tail;
            // Clear links of returned element
            head->head = nullptr;
            result->tail = nullptr;
            return result;
        }

        /**
        *   @brief Inserts elements at the specified location in the container.
        *   Inserts value before pos.\n
        *   Sets up real head and tail before insertion.\n
        *   No iterators or references are invalidated, except end() if pos == end().
        *   @param pos Iterator to element before wich value must be inserted.
        *   @param value Pointer to inserted element.
        *   @return Iterator pointing to the inserted value.
        *   @complexity Linear in size of uncounted front and back elements or constant.
        **/
        iterator insert(const_iterator pos, pointer value)
        {
            // Inserted value cleanup
            if (value->head) {
                value->head->tail = value->tail;
                value->head = nullptr;
            }
            if (value->tail) {
                value->tail->head = value->head;
                value->tail = nullptr;
            }
            // Set real head element
            setHead();
            // Set real tail element
            setTail();
            if (pos.current) { // Case when pos is valid iterator to some element 
                if (const_cast<pointer>(pos.current) == head) // Case of head element
                    push_front(value);
                else if (const_cast<pointer>(pos.current) == tail) // Case of tail element
                    push_back(value);
                else { // Case of intermidiate element
                    auto ptr_ = const_cast<pointer>(pos.current);
                    value->head = ptr_->head;
                    ptr_->head->tail = value;
                    prt_->head = value;
                    value->tail = ptr_;
                }
            } else if (pos.last) { // Case when pos is end() iterator
                auto ptr_ = const_cast<pointer>(pos.current);
                if (ptr_->tail) { // Case when pos is not proper end() iterator
                    ptr_->tail->head = value;
                    value->tail = ptr_->tail;
                }
                ptr_->tail = value;
                value->head = ptr_;
            } else // Case when pos is end() iterator of empty container
                push_back(value);

            return iterator{ value }; 
        }

        /**
        *   @brief Inserts a new element into the container directly before pos.
        *   The element is constructed through new EntryT expression.\n
        *   The arguments args... are forwarded to the constructor as std::forward<Args>(args)...\n
        *   Construction and insertion are performed sequentially one after another.\n
        *   No iterators or references are invalidated, except end() if pos == end().
        *   @param pos Iterator to element before wich value must be inserted.
        *   @param args Arguments to be forwarded to constructor.
        *   @return Iterator pointing to the emplaced element, or end() if construction of value throwed exception.
        *   @complexity Linear in size of uncounted front and back elements or constant.
        *   @todo Add debug msg
        **/
        template< class EntryT,  class... Args > 
        iterator emplace( const_iterator pos, Args&&... args )
        {
            static_assert(  std::is_base_of<value_type, EntryT>::value,
                            "STATIC_ARREST::cPipeline::emplace::Provided type EntryT is not derived from value_type of container.")
            static_assert(  std::is_constructible<EntryT, Args...>::value, 
                            "STATIC_ARREST::cPipeline::emplace::Provided type EntryT is not constructible from provided Args.");
            pointer buffer = nullptr;
            try {
                buffer = new EntryT(std::forward<Args>(args)...);
            }
            catch (...) {
                //todo: add debug msg
                return end();
            }
            return insert(pos, buffer);
        }

        /**
        *   @brief Removes specified elements from the container.
        *   Removes the element at pos.\n
        *   Sets up real head and tail before removal.\n
        *   No iterators or references are invalidated, except end() if pos == end().
        *   @param pos Iterator to the element to remove.
        *   @return Iterator following the last removed element. If the iterator pos refers to the last element, the end() iterator is returned. If pos is not proper element iterator to pos is returned.
        *   @complexity Linear in size of uncounted front and back elements or constant.
        *   @todo Add debug msg x5
        **/
        iterator erase( const_iterator pos )
        {
            // Set real head element
            setHead();
            // Set real tail element
            setTail();
            //RVO
            iterator result = end();
            if (!pos.current) return result; // Case of pos == end()
            result.last = nullptr; // Clean effects of end() iterator
            auto obj = const_cast<pointer>(pos.current);
            if (obj == head) { // Case of pos == begin()
                try { delete pop_front(); }
                catch(...) { 
                    //todo: add dbg msg 
                }
                result.current = head
                return result;
            }
            if (obj == tail) { // Case of pos == --end()
                try { delete pop_back(); }
                catch(...) {
                    //todo: add dbg msg 
                }
                result = end();
                return result;
            }
            // Case of pos is some intermidiate element
            if (obj->head)
                obj->head->tail = obj->tail;
            else { // pos is not a proper element 
                //todo: add dbg msg
                result.current = obj
                return result; // Return iterator to pos
            }

            if (obj->tail) 
                obj->tail->head = obj->head;
            else { // pos is not a proper element 
                //todo: add dbg msg
                result.current = obj
                return result; // Return iterator to pos
            }

            result.current = obj->tail;
            try { delete obj; }
            catch(...) { 
                //todo: add dbg msg 
            }
            return result; // Return iterator to element past the pos
        }
        
        /**
        *   @brief Removes specified elements from the container.
        *   Removes the elements in the range [first; last).\n
        *   Sets up real head and tail before removal.\n
        *   No iterators or references are invalidated, except end() if end() in [first; last].
        *   @param first Iterator to the first element to be removed.
        *   @param last Iterator to the element on wich to stop removal.        
        *   @return Iterator following the last removed element. If the iterator pos refers to the last element, the end() iterator is returned. If pos is not proper element iterator to pos is returned.
        *   @complexity Linear in size of uncounted front and back elements or constant.
        *   @todo Add debug msg x3
        **/
        iterator erase( const_iterator first, const_iterator last ) 
        {
            // Case when first == last or first is end()
            if (first == last || !first.current) return end();
            // Set real head element
            setHead();
            // Set real tail element
            setTail();
            if (last.current) { // Case when last is some element
                // Obtain pointers to objects
                auto firstObj = const_cast<pointer>(first.current);
                auto lastObj = const_cast<pointer>(last.current);
                pointer beforeLastObj = firstObj;
                // Check that first and last is connected via tail chain
                while (beforeLastObj->tail != lastObj) {
                    if (beforeLastObj->tail)
                        beforeLastObj = beforeLastObj->tail;
                    else
                        return end();
                }
                // Remove dependency
                beforeLastObj->tail = nullptr;
                if (firstObj == head) { // Case when [first; last) == [begin(); some_elem)
                    head = lastObj;
                    lastObj->head = nullptr;
                } else if (firstObj->head) { // Case when [first; last) == [some_elem; some_elem)
                    firstObj->head->tail = lastObj;
                    lastObj->head = firstObj->head;
                } else { // Case when first is not proper element, restore tail chain and exit
                    beforeLastObj->tail = lastObj;
                    //todo: add dbg msg 
                    return end();
                }
                // Push object chain to clear facility 
                clear(firstObj);
                return iterator{ lastObj };
            } else { // Case when last is end()
                auto obj = const_cast<pointer>(first.current);
                // Case when [first; last) == [begin(); end())
                if (obj == head) clear();
                // Case when [first; last) == [--end(); end())
                if (obj == tail) {
                    try { delete pop_back(); }
                    catch(...) {
                        //todo: add dbg msg 
                    }
                    return end();
                }
                // Remove dependency and set new tail
                if (obj->head) { // Case when [first; last) == [some_elem; end())
                    obj->head->tail = nullptr;
                    tail = obj->head;
                } else { // Case when first is not proper element
                    //todo: add dbg msg
                    return end();
                }
                // Push object chain to clear facility 
                clear(obj);
                return end();
            }
        }

        /**
        *   @brief Appends a new element to the end of the container.
        *   The element is constructed through new EntryT expression.\n
        *   The arguments args... are forwarded to the constructor as std::forward<Args>(args)...\n
        *   Construction and insertion are performed sequentially one after another.\n
        *   No iterators or references are invalidated, except end().
        *   @param args Arguments to be forwarded to constructor.
        *   @return A reference to the inserted element.
        *   @complexity Linear in size of uncounted front and back elements or constant.
        *   @exception std::runtime_error In case when emplace return end() iterator.
        **/
        template< class EntryT, class... Args >
        reference emplace_back( Args&&... args )
        {
            static_assert(  std::is_base_of<value_type, EntryT>::value,
                            "STATIC_ARREST::cPipeline::emplace_back::Provided type EntryT is not derived from value_type of container.")
            static_assert(  std::is_constructible<EntryT, Args...>::value, 
                            "STATIC_ARREST::cPipeline::emplace_back::Provided type EntryT is not constructible from provided Args.");
            auto result = emplace<EntryT, Args...>(end(), std::forward<Args>(args)...);
            if (result.current)
                return *result;
            else
                throw std::runtime_error("Pipeline::emplace_back::Can't construct new element.");
        }

        /**
        *   @brief Inserts a new element to the beginning of the container. 
        *   The element is constructed through new EntryT expression.\n
        *   The arguments args... are forwarded to the constructor as std::forward<Args>(args)...\n
        *   Construction and insertion are performed sequentially one after another.\n
        *   No iterators or references are invalidated.
        *   @param args Arguments to be forwarded to constructor.
        *   @return A reference to the inserted element.
        *   @complexity Linear in size of uncounted front and back elements or constant.
        *   @exception std::runtime_error In case when emplace return end() iterator.
        **/
        template< class EntryT, class... Args >
        reference emplace_front( Args&&... args )
        {
            static_assert(  std::is_base_of<value_type, EntryT>::value,
                            "STATIC_ARREST::cPipeline::emplace_front::Provided type EntryT is not derived from value_type of container.")
            static_assert(  std::is_constructible<EntryT, Args...>::value, 
                            "STATIC_ARREST::cPipeline::emplace_front::Provided type EntryT is not constructible from provided Args.");
            auto result = emplace<EntryT, Args...>(begin(), std::forward<Args>(args)...);
            if (result.current)
                return *result;
            else
                throw std::runtime_error("Pipeline::emplace_front::Can't construct new element.");
        }
        
        /**
        *   @brief Exchanges the contents of the container with those of other.
        *   Does not invoke any move, copy, or swap operations on individual elements.\n
        *   All iterators and references remain valid. 
        *   @param other Container to exchange the contents with
        *   @return Noreturn
        *   @complexity Constant.
        **/
        void swap( Pipeline& other ) noexcept { std::swap(head, other.head); std::swap(tail, other.tail); }

        //@}
    private:
        pointer head;   //!< Pointer to head of container
        pointer tail;   //!< Pointer to tail of container

        /**
        *   @brief Searches and setups real container head value.
        *   @return Noreturn
        *   @complexity Linear in size of uncounted front elements. 
        **/
        inline void setHead() noexcept
        {
            if (!head) // If head is not a valid pointer
                if (tail) // If tail is valid pointer -> setup head = tail
                    head = tail;
                else
                    return; // Container is empty
            
            while (head->head) // Iterate over head chain while there is a link
                head = head->head;
        }

        /**
        *   @brief Searches and setups real container tail value.
        *   @return Noreturn
        *   @complexity Linear in size of uncounted front elements. 
        **/
        inline void setTail() noexcept
        {
            if (!tail) // If tail is not a valid pointer
                if (head) // If head is valid pointer -> setup tail = head
                    tail = head;
                else
                    return;
            
            while (tail->tail) // Iterate over tail chain while there is a link
                tail = tail->tail;
        }

        /**
        *   @brief Iteratively safely deallocate all elements starting with ptr_.
        *   delete expression is used to deallocate elements.\n
        *   Elements are removed following a tail chain.
        *   @param ptr_ Element to start removal with.
        *   @return Noreturn
        *   @complexity Linear in size of provided tail chain.
        *   @todo Add debug msg x2
        **/
        static void clear(pointer ptr_) noexcept 
        {
            pointer next = nullptr;
            for(;;) {
                if (ptr_) next = ptr_->tail;
                try { delete ptr_; }
                catch(std::exception& e) {
                    //TODO: add debug_out msg
                }
                catch(...) {
                    //TODO: add debug_out msg
                }
                if (next)
                    ptr_ = next;
                else
                    break;
            }
        }
    };

    /**
    *   Special type to be used in derive expression for classes of pipeline.
    *   Example:
    *   @code
    *   class WorkingClass : public PipelineEntry<SomeInterface> { ... }
    *   @endcode
    **/
    template < typename InterfaceT >
    using PipelineEntry = typename Pipeline<InterfaceT>::PipelineEntry;

}

#endif